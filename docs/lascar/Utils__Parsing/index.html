<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Utils__Parsing (lascar.Utils__Parsing)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">lascar</a> &#x00BB; Utils__Parsing</nav><h1>Module <code>Utils__Parsing</code></h1><h3 id="some-functions-for-building-recursive-descent-parsers-using-the-stream-and-genlex-modules"><a href="#some-functions-for-building-recursive-descent-parsers-using-the-stream-and-genlex-modules" class="anchor"></a>Some functions for building recursive descent parsers using the Stream and Genlex modules</h3><nav class="toc"><ul><li><a href="#higher-order-parsers">Higher order parsers</a></li><li><a href="#useful-wrappers">Useful wrappers</a></li></ul></nav></header><section><header><h4 id="higher-order-parsers"><a href="#higher-order-parsers" class="anchor"></a>Higher order parsers</h4></header><dl><dt class="spec value" id="val-separated_list"><a href="#val-separated_list" class="anchor"></a><code><span class="keyword">val</span> separated_list : string <span>&#45;&gt;</span> <span>?&#8288;stop_on:<span>string option</span></span> <span>&#45;&gt;</span> <span>(<span>Stdlib.Genlex.token Stdlib.Stream.t</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>Stdlib.Genlex.token Stdlib.Stream.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>separated_list sep p ss</code> parses stream <code>ss</code> as a <code>sep</code>-separated list of elements parsed by <code>p</code> and returns the list of parsed element. Parsing fails if <code>p</code> fails or a token non equal to <code>sep</code> occurs in <code>ss</code> unless the <code>stop_on</code> optional argument is set to <code>Some t</code>. In this case, parsing stops and returns the list parsed so far when the token equal to <code>c</code> is read. This mechanism is required for parsing grammars in which empty list can be used as optional parts (see for example the syntax of <code>!Fsm_transition</code>s.</p></dd></dl></section><section><header><h4 id="useful-wrappers"><a href="#useful-wrappers" class="anchor"></a>Useful wrappers</h4></header><dl><dt class="spec value" id="val-run"><a href="#val-run" class="anchor"></a><code><span class="keyword">val</span> run : <span>lexer:<span>(string <span>&#45;&gt;</span> <span>Stdlib.Genlex.token Stdlib.Stream.t</span>)</span></span> <span>&#45;&gt;</span> <span>parser:<span>(<span>Stdlib.Genlex.token Stdlib.Stream.t</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span>Stdlib.Genlex.token option</span>)</span> Stdlib.Result.t</span></code></dt><dd><p><code>run lexer parser src</code> builds a stream of token <code>ss</code> by applying <code>lexer</code> to <code>src</code>, applies <code>parser</code> to this stream and returns either <code>Ok r</code> if parsing succeeds (with result <code>r</code>) or <code>Error e</code> if parsing fails (with <code>e=Some t</code> and <code>t</code> the current lookahead token or <code>e=None</code> if the remaining input stream is empty.</p></dd></dl><dl><dt class="spec exception" id="exception-Parse_error"><a href="#exception-Parse_error" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Parse_error</span> <span class="keyword">of</span> string * <span>Stdlib.Genlex.token option</span></code></dt><dd><p>Parsed string, lookahead token</p></dd></dl><dl><dt class="spec value" id="val-try_run"><a href="#val-try_run" class="anchor"></a><code><span class="keyword">val</span> try_run : <span>lexer:<span>(string <span>&#45;&gt;</span> <span>Stdlib.Genlex.token Stdlib.Stream.t</span>)</span></span> <span>&#45;&gt;</span> <span>parser:<span>(<span>Stdlib.Genlex.token Stdlib.Stream.t</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>try_run lexer parser src</code> is like <a href="index.html#val-run"><code>run</code></a> except that it just raises exception <a href="index.html#exception-Parse_error"><code>Parse_error</code></a> if parsing fails</p></dd></dl></section></div></body></html>