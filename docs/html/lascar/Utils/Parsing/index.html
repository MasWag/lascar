<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Parsing (lascar.Utils.Parsing)</title><link rel="stylesheet" href="../../../_odoc_support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../_odoc_support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">lascar</a> &#x00BB; <a href="../index.html">Utils</a> &#x00BB; Parsing</nav><header class="odoc-preamble"><h1>Module <code><span>Utils.Parsing</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#some-functions-for-building-recursive-descent-parsers-using-the-stream-and-genlex-modules">Some functions for building recursive descent parsers using the Stream and Genlex modules</a><ul><li><a href="#higher-order-parsers">Higher order parsers</a></li><li><a href="#useful-wrappers">Useful wrappers</a></li></ul></li></ul></nav><div class="odoc-content"><h3 id="some-functions-for-building-recursive-descent-parsers-using-the-stream-and-genlex-modules"><a href="#some-functions-for-building-recursive-descent-parsers-using-the-stream-and-genlex-modules" class="anchor"></a>Some functions for building recursive descent parsers using the Stream and Genlex modules</h3><h4 id="higher-order-parsers"><a href="#higher-order-parsers" class="anchor"></a>Higher order parsers</h4><div class="odoc-spec"><div class="spec value anchored" id="val-separated_list"><a href="#val-separated_list" class="anchor"></a><code><span><span class="keyword">val</span> separated_list : 
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span>?stop_on:<span>string option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span class="xref-unresolved">Genlex</span>.token <span class="xref-unresolved">Stream</span>.t</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">Genlex</span>.token <span class="xref-unresolved">Stream</span>.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>separated_list sep p ss</code> parses stream <code>ss</code> as a <code>sep</code>-separated list of elements parsed by <code>p</code> and returns the list of parsed element. Parsing fails if <code>p</code> fails or a token non equal to <code>sep</code> occurs in <code>ss</code> unless the <code>stop_on</code> optional argument is set to <code>Some t</code>. In this case, parsing stops and returns the list parsed so far when the token equal to <code>c</code> is read. This mechanism is required for parsing grammars in which empty list can be used as optional parts (see for example the syntax of <code>!Fsm_transition</code>s.</p></div></div><h4 id="useful-wrappers"><a href="#useful-wrappers" class="anchor"></a>Useful wrappers</h4><div class="odoc-spec"><div class="spec value anchored" id="val-run"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : 
  <span>lexer:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Genlex</span>.token <span class="xref-unresolved">Stream</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>parser:<span>(<span><span><span class="xref-unresolved">Genlex</span>.token <span class="xref-unresolved">Stream</span>.t</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span><span class="xref-unresolved">Genlex</span>.token option</span>)</span> <span class="xref-unresolved">Stdlib</span>.Result.t</span></span></code></div><div class="spec-doc"><p><code>run lexer parser src</code> builds a stream of token <code>ss</code> by applying <code>lexer</code> to <code>src</code>, applies <code>parser</code> to this stream and returns either <code>Ok r</code> if parsing succeeds (with result <code>r</code>) or <code>Error e</code> if parsing fails (with <code>e=Some t</code> and <code>t</code> the current lookahead token or <code>e=None</code> if the remaining input stream is empty.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Parse_error"><a href="#exception-Parse_error" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Parse_error</span> <span class="keyword">of</span> string * <span><span class="xref-unresolved">Genlex</span>.token option</span></span></code></div><div class="spec-doc"><p>Parsed string, lookahead token</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-try_run"><a href="#val-try_run" class="anchor"></a><code><span><span class="keyword">val</span> try_run : 
  <span>lexer:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Genlex</span>.token <span class="xref-unresolved">Stream</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>parser:<span>(<span><span><span class="xref-unresolved">Genlex</span>.token <span class="xref-unresolved">Stream</span>.t</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>try_run lexer parser src</code> is like <a href="#val-run"><code>run</code></a> except that it just raises exception <a href="#exception-Parse_error"><code>Parse_error</code></a> if parsing fails</p></div></div></div></body></html>